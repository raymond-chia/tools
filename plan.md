# 完整戰鬥模擬系統實作計劃

## Context（背景）

**為什麼需要這個功能？**

- 編輯器目前只能編輯關卡（棋盤尺寸、單位配置、物件配置），無法測試戰鬥平衡性
- 需要完整的戰鬥模擬來驗證關卡設計是否合理（敵人強度、技能搭配等）
- 提供快速測試環境，避免每次都要進入遊戲才能測試

**目標**：在編輯器中實作完整的回合制戰鬥模擬，包含：

- 屬性計算（**從被動技能計算單位屬性**）
- 判定系統（命中、DC 檢定、必中）
- 傷害計算系統
- 技能執行系統（HpModify、AttributeModify、Push）
- 戰鬥流程（**每回合重新計算 Initiative**、多回合、**戰鬥到一方全滅**）
- 手動控制介面（由用戶控制雙方單位）
- 結果呈現（**文字日誌**、可重播）

---

## 設計決策

基於用戶需求和 CLAUDE.md 規則，做出以下設計決策：

### 1. 控制方式：手動控制（由用戶操作雙方）

- **不先做 AI**，直接支援手動操作
- 在編輯器中提供控制介面（選擇單位、技能、目標）
- 決策層和執行層分離（未來可以輕鬆加入 AI）
- 符合「只補現在用到的內容」原則

### 2. Initiative 計算：每回合重新計算

- 不是固定順序，而是**動態計算**
- 每回合開始時根據單位當前屬性重新排序
- 戰術意義：Buff/Debuff 會影響下回合的行動順序
- 提高戰鬥策略性

### 3. 亂數記錄：完整記錄用於重播

- **BattleEvent** 需要記錄每次隨機結果（random_seed）
- 例如：命中檢定、傷害計算、暴擊判定
- 允許完全相同的戰鬥重播（不受隨機性影響）
- 為未來「回放到第 N 回合」功能做準備

### 4. 參數傳遞策略：漸進式設計

- **平常用參數直接傳遞**（遵循「只補現在用到的內容」）
- 只有參數 > 5 個時，才考慮用 struct 封裝
- 不預先優化（如 UnitInstance）
- 需要時再重構

### 4.5 倍率表示：整數百分比（100 = 100%）

- **倍率統一用整數表示**（不用浮點數）
- 100 = 100%、150 = 150%、75 = 75%
- 優點：完全確定性、支援重播、無浮點誤差
- 計算方式：`damage = (base_value * multiplier) / 100`
- 精度：1%（足夠遊戲設計使用）

### 5. 單位屬性來源：從被動技能計算

- UnitType 不添加基礎屬性欄位
- 單位的所有屬性（HP、MP、Initiative 等）完全由被動技能決定
- 掃描技能中的 `TriggerEvent::Passive` + `SkillEffect::AttributeModify`
- 符合**數據驅動設計**原則

### 6. 架構設計

- **ECS 架構**：使用 bevy_ecs 管理戰鬥狀態（Component）
- **業務邏輯**：放在 `core/board/src/logic/`（純函數）
- **Single responsibility**：每個模組只負責一項職責
  - `mechanic.rs`：判定邏輯
  - `formula.rs`：傷害/數值計算
  - `skill_execution.rs`：技能執行
  - `combat.rs`：戰鬥流程和事件記錄

---

## 實作步驟

### **第一步：單位屬性計算** 📦 (Done)

**目標**：從被動技能計算單位屬性

**做什麼**：

- 掃描單位的所有技能，找出被動技能（`TriggerEvent::Passive`）
- 應用被動技能的 `AttributeModify` 效果
- 計算出單位的最終屬性（HP、MP、Initiative、攻擊、防禦等）
- 定義戰鬥用的單位資料結構（包含當前 HP、MP、位置等）

**檔案**：

- `core/board/src/logic/` 新增模組
- `core/board/src/component.rs` 添加 Component

**驗收標準**：

- ✅ 無被動技能的單位，所有屬性為 0
- ✅ 有被動技能的單位，屬性正確累加
- ✅ 多個被動技能，屬性正確疊加
- ✅ `cargo check -p board` 通過

---

### **第二步：基礎判定系統** 🎲

**目標**：實作 Mechanic 的判定邏輯

**做什麼**：

- 實作命中判定（HitBased）：命中 + 1d100 vs 閃避 + 格擋 + 1d100
- 實作 DC 檢定（DcBased）：DC + 1d100 vs 豁免 + 1d100
- 實作必中機制（Guaranteed）：永遠成功
- 使用 seed 參數化隨機數（支援重播）
- 定義常數（不使用 magic numbers）

**檔案**：

- `core/board/src/logic/mechanic.rs`（新增）
- `core/board/src/constants.rs`（新增或修改）

**驗收標準**：

- ✅ 命中判定邏輯正確（包含暴擊、格擋）
- ✅ DC 檢定邏輯正確
- ✅ 必中機制永遠成功
- ✅ 相同 seed 產生相同結果
- ✅ `cargo check -p board` 通過

---

### **第三步：傷害計算系統** 🧮

**目標**：實作 ValueFormula 的計算邏輯

**做什麼**：

- 實作固定數值公式（Fixed）
- 實作屬性倍率公式（Attribute）：根據施放者或目標屬性計算
- 正確處理小數倍率（四捨五入）

**檔案**：

- `core/board/src/logic/formula.rs`（新增）

**驗收標準**：

- ✅ 固定數值公式正確
- ✅ 屬性倍率公式正確（施放者/目標）
- ✅ 小數倍率四捨五入正確
- ✅ `cargo check -p board` 通過

---

### **第四步：技能執行系統** ⚔️

**目標**：實作 SkillEffect 的執行邏輯

**做什麼**：

- 實作 HpModify 效果：傷害/治療計算，結合判定和公式
- 實作 AttributeModify 效果：buff/debuff、持續時間
- 實作 Push 效果：位移、邊界檢查
- 記錄每次執行的結果和 seed

**檔案**：

- `core/board/src/logic/skill_execution.rs`（新增）

**驗收標準**：

- ✅ HpModify 正確執行（命中、未命中、暴擊、格擋）
- ✅ AttributeModify 正確執行
- ✅ Push 正確執行（邊界檢查）
- ✅ seed 正確傳遞
- ✅ `cargo check -p board` 通過

---

### **第五步：戰鬥流程系統** 🔄

**目標**：實作回合制戰鬥流程

**做什麼**：

- **每回合重新計算 Initiative**（根據單位當前屬性排序）
- 執行單位行動（移動、使用技能）
- 應用技能效果到目標
- 記錄所有事件（BattleEvent）和 seed
- 判定勝負（**一方全滅**）
- 支援多回合戰鬥

**檔案**：

- `core/board/src/logic/combat.rs`（新增）

**驗收標準**：

- ✅ Initiative 每回合重新計算
- ✅ 單位依序行動
- ✅ 技能效果正確應用
- ✅ 勝負判定正確（全滅）
- ✅ 事件日誌完整記錄
- ✅ seed 鏈式傳遞正確
- ✅ `cargo check -p board` 通過

---

### **第六步：編輯器整合 - 手動控制** 📝

**目標**：在編輯器中提供手動控制和戰鬥日誌顯示

**做什麼**：

- 添加「開始戰鬥模擬」按鈕
- 提供單位、技能、目標的選擇介面
- 載入 units.toml 和 skills.toml
- 每回合讓用戶依序操作每個單位
- **顯示文字日誌**（每個事件）
- 顯示單位 HP、位置變化
- 顯示最終勝負結果

**檔案**：

- `editor/src/tabs/level_tab.rs`

**驗收標準**：

- ✅ 能啟動戰鬥模擬
- ✅ 能選擇單位、技能、目標
- ✅ 能執行技能並看到效果
- ✅ 文字日誌完整顯示（可滾動）
- ✅ 顯示最終結果（勝負）
- ✅ `cargo check` 通過

---

### **第七步：回合重播功能**（可選） 🔁

**目標**：基於事件日誌重播戰鬥到指定回合

**做什麼**：

- 從事件日誌重新執行戰鬥
- 提供「上一回合」「下一回合」按鈕
- 顯示指定回合的棋盤狀態

**檔案**：

- `core/board/src/logic/combat.rs`
- `editor/src/tabs/level_tab.rs`

**驗收標準**：

- ✅ 能從事件日誌重播
- ✅ 能切換回合
- ✅ 顯示正確的棋盤狀態
- ✅ `cargo check` 通過

---

## 驗證方式

### 每一步的驗證流程

1. **TDD 測試**：
   - 先寫失敗的測試（定義預期行為）
   - 實現邏輯使測試通過
   - 重構代碼（保持測試通過）
   - 測試檔案位置：`core/board/tests/combat/`

2. **檢查指令**：
   - 只用 `cargo check`
   - 禁止用 `cargo run` 或 `cargo build`
   - 如需檢查特定 crate：`cargo check -p board`

3. **編輯器測試**（第五、六步）：
   - 啟動編輯器
   - 開啟關卡編輯 tab
   - 手動操作戰鬥
   - 驗證日誌和結果

### 設計機制檢查

完成後檢查是否違反 `README-設計機制.md`：

- 如果違反：警告使用者
- 如果只是尚未實作完畢：提示尚未實作

---

## 重要規則提醒

- ✅ **語言**：繁體中文註解，禁止簡體中文
- ✅ **禁止盲目附和**：驗證設計，不直接認可
- ✅ **先討論後實作**：每步驗收後再進行下一步
- ✅ **禁止 unwrap()**：使用 expect() 並提供清晰錯誤訊息
- ✅ **禁止 magic numbers**：使用常數
- ✅ **使用 match 而不要 let else**
- ✅ **Fail fast**：在函數開頭驗證
- ✅ **只補現在用到的內容**：不預先優化，參數傳遞優先
- ✅ **優先 derive**：除非無法 derive
- ✅ **use 語句放頂部**
- ✅ **Functional programming**：優先使用函數式風格
- ✅ **優先使用 alias**：使用 `Coord`、`MovementCost`、`ID`、`TypeName`、`SkillName`
- ✅ **每回合重新計算 Initiative**：增加戰鬥動態性
- ✅ **完整記錄亂數**：使用 seed 參數化，支援重播
